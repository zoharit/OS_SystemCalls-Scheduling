diff --git a/Makefile b/Makefile
index 920b6a3..9a89378 100644
--- a/Makefile
+++ b/Makefile
@@ -198,6 +198,8 @@ UPROGS=\
 	_stressfs\
 	_wc\
 	_zombie\
+	_sanity\
+	_policy\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -266,8 +268,8 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c sanity.c\
+	printf.c umalloc.c policy.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/ass1ds.cpp b/ass1ds.cpp
index b93fb11..6b9c514 100644
--- a/ass1ds.cpp
+++ b/ass1ds.cpp
@@ -2,9 +2,11 @@
 
 extern "C" {
 	char*                         kalloc();
+	void                          panic(char*) __attribute__((noreturn));
 	void*                         memset(void*, int, uint);
 	void                          initSchedDS();
 	long long                     getAccumulator(Proc *p);
+	long long                     __moddi3(long long number, long long divisor);
 
 	//for pq
 	static boolean                isEmptyPriorityQueue();
@@ -212,7 +214,7 @@ static MapNode* allocNode(Proc *p, long long key) {
 	if(!ans)
 		return null;
 
-	if(!ans->listOfProcs.enqueue(p)){
+	if(!ans->listOfProcs.enqueue(p)) {
 		deallocNode(ans);
 		return null;
 	}
@@ -305,14 +307,16 @@ bool LinkedList::transfer() {
 	if(!priorityQ->isEmpty())
 		return false;
 	
-	MapNode *node = allocNode(0);
-	if(!node)
-		return false;
-	
-	node->listOfProcs.first = first;
-	node->listOfProcs.last = last;
-	first = last = null;
-	priorityQ->root = node;
+	if(!isEmpty()) {
+		MapNode *node = allocNode(0);
+		if(!node)
+			return false;
+		
+		node->listOfProcs.first = first;
+		node->listOfProcs.last = last;
+		first = last = null;
+		priorityQ->root = node;
+	}
 	return true;
 }
 
@@ -459,3 +463,29 @@ bool Map::extractProc(Proc *p) {
 	root = tempMap.root;
 	return ans;
 }
+
+long long __moddi3(long long number, long long divisor) { //returns number%divisor
+	if(divisor == 0)
+		panic((char*)"divide by zero!!!\n");
+
+	bool isNumberNegative = false;
+	if(number < 0) {
+		number = -number;
+		isNumberNegative = true;
+	}
+
+	if(divisor < 0)
+		divisor = -divisor;
+
+	for(;;) {
+		long long divisor2 = divisor;
+		while(number >= divisor2) {
+			number -= divisor2;
+			if(divisor2 + divisor2 > 0) //exponential decay.
+				divisor2 += divisor2;
+		}
+
+		if(number < divisor)
+			return isNumberNegative ? -number : number;
+	}
+}
\ No newline at end of file
diff --git a/cat.c b/cat.c
index 5ddc820..ed1987d 100644
--- a/cat.c
+++ b/cat.c
@@ -12,12 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      exit();
+      exit(0);
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit();
+    exit(0);
   }
 }
 
@@ -28,16 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     cat(fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/defs.h b/defs.h
index 82fb982..dbc7531 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct perf;
 
 // bio.c
 void            binit(void);
@@ -104,7 +105,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-void            exit(void);
+void            exit(int status);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -113,17 +114,21 @@ struct proc*    myproc();
 void            pinit(void);
 void            procdump(void);
 void            scheduler(void) __attribute__((noreturn));
+void            schedulerRR(struct proc *p, struct cpu* c);
 void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(void);
+int             wait(int *status);
+int             detach(int pid);
+void            priority(int acc);
 void            wakeup(void*);
 void            yield(void);
-
-// swtch.S
+void            policy(int pol);
+int             wait_stat(int * status, struct perf * performance);
+//void Priority_Scheduler(struct cpu* c);
+//void Extended_Priority_Scheduler(struct cpu* c);
 void            swtch(struct context**, struct context*);
-
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -132,6 +137,8 @@ void            initlock(struct spinlock*, char*);
 void            release(struct spinlock*);
 void            pushcli(void);
 void            popcli(void);
+void            changePriority1To0();
+void            change_accumulator_to_zero();
 
 // sleeplock.c
 void            acquiresleep(struct sleeplock*);
@@ -148,6 +155,7 @@ int             strlen(const char*);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);
 
+
 // syscall.c
 int             argint(int, int*);
 int             argptr(int, char**, int);
diff --git a/echo.c b/echo.c
index 806dee0..eed68a0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
+  exit(0);
 }
diff --git a/forktest.c b/forktest.c
index 8bc984d..4cbcb17 100644
--- a/forktest.c
+++ b/forktest.c
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(0);
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit();
+    exit(0);
   }
 
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(0) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(0);
     }
   }
 
-  if(wait() != -1){
+  if(wait(0) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit();
+  exit(0);
 }
diff --git a/grep.c b/grep.c
index adc4835..1aa1081 100644
--- a/grep.c
+++ b/grep.c
@@ -43,24 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit();
+    exit(0);
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    exit();
+    exit(0);
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/init.c b/init.c
index 046b551..8da3b90 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit();
+      exit(0);
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit();
+      exit(0);
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+    while((wpid=wait(0)) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/kill.c b/kill.c
index 364f6af..5a2e450 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 2){
     printf(2, "usage: kill pid...\n");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit();
+  exit(0);
 }
diff --git a/ln.c b/ln.c
index cf8a64e..14acdc8 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit();
+    exit(0);
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
+  exit(0);
 }
diff --git a/ls.c b/ls.c
index 2862913..27742c2 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit();
+  exit(0);
 }
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..d101838 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/policy.c b/policy.c
new file mode 100644
index 0000000..666423c
--- /dev/null
+++ b/policy.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+
+int main ( int argc, char **argv ) {
+    //check the we got the policy number
+    if(argc>0){
+         policy(atoi(argv[1]));
+    }
+    else{
+        printf(1,"ERROR! we didnt get any policy number- please try again");
+    }
+exit(0);
+} 
diff --git a/proc.c b/proc.c
index e68bf1c..54cbb5c 100644
--- a/proc.c
+++ b/proc.c
@@ -8,13 +8,24 @@
 #include "proc.h"
 #include "spinlock.h"
 
+//all the queues we use for each policy.
 extern PriorityQueue pq;
 extern RoundRobinQueue rrq;
 extern RunningProcessesHolder rpholder;
+// counts the numbers of times that any process gets running time.
+long long counter=0;
+// enum that represent the policy number that we got (RRQ= round robin queue, PQ= priority queue, EPQ= extended priority queue)
+enum CurrPolicyCase{
+  RRQ=1,
+  PQ=2,
+  EPQ=3,
+};
+// we set our priority to RRQ because its our default policy
+enum CurrPolicyCase current=RRQ;
+
 
 long long getAccumulator(struct proc *p) {
-	//Implement this function, remove the panic line.
-	panic("getAccumulator: not implemented\n");
+  return p->accumulator;
 }
 
 struct {
@@ -23,23 +34,110 @@ struct {
 } ptable;
 
 static struct proc *initproc;
-
 int nextpid = 1;
 extern void forkret(void);
 extern void trapret(void);
-
 static void wakeup1(void *chan);
 
+
+
+/*
+ extends the wait system call
+ the second argument is a pointer to the structure that contains:
+ ctime,ttime,stime,retime,rutime.
+*/
+int
+wait_stat(int *status,  struct perf * performance)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        performance->ctime = p->ctime;
+        performance->ttime = p->ttime;
+        performance->stime = p->stime;
+        performance->retime = p->retime;
+        performance->rutime = p->rutime;
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+      if(status!=null){
+        *status=p->status;
+      }
+        p->state = UNUSED;
+        p->status=0;
+        p->accumulator=0;
+        p->priority=0;
+        p->last_running_time=0;
+        p->ctime = 0;
+        p->ttime = 0;
+        p->stime = 0;
+        p->retime = 0;
+        p->rutime = 0;
+   
+      release(&ptable.lock);
+      return pid;
+    }   
+  }   
+  // No point waiting if we don't have any children.
+  if(!havekids || curproc->killed){
+    release(&ptable.lock);
+    return -1;
+  }
+
+  // Wait for children to exit. (See wakeup1 call in proc_exit.)
+  sleep(curproc, &ptable.lock); //DOC: wait-sleep
+  }
+}
+
+//get the min accumulator
+long long get_min (void)
+{
+  if(pq.isEmpty())
+    return 0;
+  
+  //min_accumulator_rpholder store the min from the running queue
+  //min_accumulator_pq store the min from the runnable queue
+  long long min_accumulator_pq=0;
+  long long min_accumulator_rpholder=0;
+  if(rpholder.isEmpty()){
+    pq.getMinAccumulator(&min_accumulator_pq);
+    return min_accumulator_pq;
+  }
+  pq.getMinAccumulator(&min_accumulator_pq);
+  rpholder.getMinAccumulator(&min_accumulator_rpholder);
+  //choose the min between the running and runnable proceses
+  if(min_accumulator_pq <min_accumulator_rpholder)
+    return min_accumulator_pq;
+  
+  return min_accumulator_rpholder;  
+}
+
+
 void
 pinit(void)
 {
-  initlock(&ptable.lock, "ptable");
+ initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
 int
 cpuid() {
-  return mycpu()-cpus;
+ return mycpu()-cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
@@ -85,33 +183,30 @@ allocproc(void)
 {
   struct proc *p;
   char *sp;
-
   acquire(&ptable.lock);
-
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
     if(p->state == UNUSED)
       goto found;
-
   release(&ptable.lock);
   return 0;
-
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
-
+  found:
+    p->ctime = ticks;
+    p->ttime = 0;
+    p->stime = 0;
+    p->retime = 0;
+    p->rutime = 0;
+    p->state = EMBRYO;
+    p->pid = nextpid++;
   release(&ptable.lock);
-
   // Allocate kernel stack.
   if((p->kstack = kalloc()) == 0){
     p->state = UNUSED;
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
-
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
-
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -121,7 +216,6 @@ found:
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
-
   return p;
 }
 
@@ -132,9 +226,7 @@ userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-  
+  p = allocproc(); 
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
@@ -147,8 +239,7 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
+  p->tf->eip = 0; // beginning of initcode.S
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
@@ -157,12 +248,26 @@ userinit(void)
   // writes to be visible, and the lock is also needed
   // because the assignment might not be atomic.
   acquire(&ptable.lock);
-
   p->state = RUNNABLE;
-
+  //set the priority to 5 in every new process
+  p->last_running_time=0;
+  p->priority=5;
+  p->accumulator=get_min();
+  p->ctime=ticks;
+
+  switch(current){
+    case RRQ:
+      rrq.enqueue(p);
+      break;
+    case PQ :
+    case EPQ:
+      pq.put(p);
+      break;
+  }
   release(&ptable.lock);
 }
 
+
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
 int
@@ -174,14 +279,14 @@ growproc(int n)
   sz = curproc->sz;
   if(n > 0){
     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
+    return -1;
   } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
+             if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+                return -1;
+            }
+   curproc->sz = sz;
+   switchuvm(curproc);
+   return 0;
 }
 
 // Create a new process copying p as the parent.
@@ -219,30 +324,39 @@ fork(void)
   np->cwd = idup(curproc->cwd);
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-
   pid = np->pid;
-
   acquire(&ptable.lock);
-
   np->state = RUNNABLE;
-
+  np->priority=5;
+  np->accumulator=get_min();
+  np->last_running_time=0;
+  np->ctime=ticks;
+
+  switch(current){
+    case RRQ:
+      rrq.enqueue(np);
+      break;
+    case PQ :
+    case EPQ:
+      pq.put(np);
+      break;
+  }
   release(&ptable.lock);
-
   return pid;
-}
+  }
 
-// Exit the current process.  Does not return.
+// Exit the current process. Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(void)
+exit(int status)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
-
+  curproc->status=status;
   if(curproc == initproc)
-    panic("init exiting");
+  panic("init exiting");
 
   // Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
@@ -252,40 +366,40 @@ exit(void)
     }
   }
 
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
+ begin_op();
+ iput(curproc->cwd);
+ end_op();
+ curproc->cwd = 0;
 
-  acquire(&ptable.lock);
+ acquire(&ptable.lock);
 
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+ // Parent might be sleeping in wait().
+ wakeup1(curproc->parent);
 
-  // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
-    }
-  }
+ // Pass abandoned children to init.
+ for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+  if(p->parent == curproc){
+   p->parent = initproc;
+  if(p->state == ZOMBIE)
+    wakeup1(initproc);
+ }
+}
 
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
+ // Jump into the scheduler, never to return.
+ curproc->state = ZOMBIE;
+ curproc->ttime=ticks;
+ sched();
+ panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
+wait(int *status)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
   acquire(&ptable.lock);
   for(;;){
     // Scan through table looking for exited children.
@@ -293,7 +407,7 @@ wait(void)
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->parent != curproc)
         continue;
-      havekids = 1;
+    havekids = 1;
       if(p->state == ZOMBIE){
         // Found one.
         pid = p->pid;
@@ -305,22 +419,149 @@ wait(void)
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        if(status!=null)
+          *status=p->status;
+       p->state = UNUSED;
+        //reset the fields
+        p->status=0;
+        p->accumulator=0;
+        p->priority=0;
+        p->last_running_time=0;
+        p->ctime = 0;
+        p->ttime = 0;
+        p->stime = 0;
+        p->retime = 0;
+        p->rutime = 0;
         release(&ptable.lock);
         return pid;
       }
-    }
 
-    // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+  }
+
+  // No point waiting if we don't have any children.
+  if(!havekids || curproc->killed){
       release(&ptable.lock);
       return -1;
-    }
+  }
+ // Wait for children to exit. (See wakeup1 call in proc_exit.)
+  sleep(curproc, &ptable.lock); //DOC: wait-sleep
+ }
+}
+
+
+/*
+ round robin scheduling algorithm-
+ each runnable process becomes running
+ when it is removed from the head of the queue
+*/
+void
+Round_Robin_Scheduler( struct cpu *c)
+{
+ struct proc *p;
+  acquire(&ptable.lock);
+ if(!(rrq.isEmpty())){
+    p = rrq.dequeue();
+    if(p!=null){
+      if(p->state == RUNNABLE){
+        c->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        swtch(&(c->scheduler), p->context);
+        switchkvm();
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+      }
+      }
+ }
+ release(&ptable.lock);
+}
 
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+
+/*
+  scheduling policy is based on accumulating the process priority (1-10)
+*/
+void Priority_Scheduler(struct cpu* c)
+{
+  acquire(&ptable.lock);
+  struct proc *p;
+  if (!pq.isEmpty()){
+    p=pq.extractMin();
+    if(p!=null){
+    if(p->state == RUNNABLE)
+    {
+      c->proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      rpholder.add(p);
+      swtch(&(c->scheduler), p->context);
+      switchkvm();
+      c->proc = 0;
+    }
   }
+  }
+  release(&ptable.lock);
 }
 
+
+
+/*
+ scheduling policy is based on accumulating the process priority (0-10)
+*/
+void Extended_Priority_Scheduler(struct cpu* c)
+{ 
+  acquire(&ptable.lock);
+  long long minimum_ticks_time=ticks;
+  struct proc *p;
+  struct proc *min_procces=0;
+    if (!pq.isEmpty() ){
+      if ((counter!=0)&&(counter%100==0))
+      {
+          for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+            if(p->state != RUNNABLE){
+            continue;
+            }
+              if (p->last_running_time<minimum_ticks_time){
+                min_procces=p;
+                minimum_ticks_time=p->last_running_time;
+              }
+          }
+        if (min_procces!=null) {
+          pq.extractProc(min_procces);
+          p=min_procces;
+        }
+      }
+      else
+      {
+        p=pq.extractMin();
+      }
+      if(p!=null){
+        if(p->state == RUNNABLE){
+            c->proc = p;
+            switchuvm(p);
+            p->state = RUNNING;
+            rpholder.add(p);
+            swtch(&(c->scheduler), p->context);
+            switchkvm();
+            c->proc = 0;
+        }
+      }
+    }
+    release(&ptable.lock);
+}
+
+
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -332,40 +573,26 @@ wait(void)
 void
 scheduler(void)
 {
-  struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
   for(;;){
     // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
+      sti();
+  switch(current){
+    case RRQ:
+      Round_Robin_Scheduler(c);
+      break;
+    case PQ :
+    Priority_Scheduler(c);
+    break;
+    case EPQ:
+      Extended_Priority_Scheduler(c);
+      break;
     }
-    release(&ptable.lock);
-
   }
 }
 
-// Enter scheduler.  Must hold only ptable.lock
+// Enter scheduler. Must hold only ptable.lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
 // kernel thread, not this CPU. It should
@@ -375,51 +602,65 @@ scheduler(void)
 void
 sched(void)
 {
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(readeflags()&FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
+ int intena;
+ struct proc *p = myproc();
+
+ if(!holding(&ptable.lock))
+   panic("sched ptable.lock");
+ if(mycpu()->ncli != 1)
+   panic("sched locks");
+ if(p->state == RUNNING)
+  panic("sched running");
+ if(readeflags()&FL_IF)
+  panic("sched interruptible");
+ intena = mycpu()->intena;
+ swtch(&p->context, mycpu()->scheduler);
+ mycpu()->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
 void
 yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); //DOC: yieldlock
   myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
+  //the process changed from running to runnable- its accumolator doesn't change
+  rpholder.remove(myproc());
+  myproc()->last_running_time = ticks;
+  counter++;
+  switch(current){
+    case RRQ:
+      rrq.enqueue(myproc());
+      break;
+    case PQ :
+    case EPQ:
+      myproc()->accumulator=myproc()->accumulator+myproc()->priority;
+      pq.put(myproc());
+      break;
+ }
+
+ sched();
+ release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
-// will swtch here.  "Return" to user space.
+// will swtch here. "Return" to user space.
 void
 forkret(void)
 {
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
+ static int first = 1;
+ // Still holding ptable.lock from scheduler.
+ release(&ptable.lock);
+ if (first) {
+ // Some initialization functions must be run in the context
+ // of a regular process (e.g., they call sleep), and thus cannot
+ // be run from main().
+ first = 0;
+ iinit(ROOTDEV);
+ initlog(ROOTDEV);
+ }
+
+ // Return to "caller", actually trapret (see allocproc).
 }
 
 // Atomically release lock and sleep on chan.
@@ -430,7 +671,7 @@ sleep(void *chan, struct spinlock *lk)
   struct proc *p = myproc();
   
   if(p == 0)
-    panic("sleep");
+   panic("sleep");
 
   if(lk == 0)
     panic("sleep without lk");
@@ -441,13 +682,14 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if(lk != &ptable.lock){ //DOC: sleeplock0
+    acquire(&ptable.lock); //DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
   p->chan = chan;
   p->state = SLEEPING;
+  rpholder.remove(p);
 
   sched();
 
@@ -455,7 +697,7 @@ sleep(void *chan, struct spinlock *lk)
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if(lk != &ptable.lock){ //DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
@@ -467,11 +709,22 @@ sleep(void *chan, struct spinlock *lk)
 static void
 wakeup1(void *chan)
 {
-  struct proc *p;
+  struct proc *p; 
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+    if(p->state == SLEEPING && p->chan == chan){
       p->state = RUNNABLE;
+      p->accumulator=get_min();
+      switch(current){
+        case RRQ:
+          rrq.enqueue(p);
+          break;
+        case PQ :
+        case EPQ:
+          pq.put(p);
+          break;
+      }
+    }
 }
 
 // Wake up all processes sleeping on chan.
@@ -490,36 +743,48 @@ int
 kill(int pid)
 {
   struct proc *p;
-
   acquire(&ptable.lock);
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING){
         p->state = RUNNABLE;
+        p->accumulator=get_min();
+         switch (current){
+            case RRQ:
+              rrq.enqueue(p);
+            break;
+            case PQ:
+              pq.put(p);
+            break;
+            case EPQ:
+              pq.put(p);
+            break;
+          }
+      }
       release(&ptable.lock);
       return 0;
-    }
+      }
   }
   release(&ptable.lock);
   return -1;
 }
 
 //PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
+// Print a process listing to console. For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
 void
 procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
+  [UNUSED] "unused",
+  [EMBRYO] "embryo",
+  [SLEEPING] "sleep ",
+  [RUNNABLE] "runble",
+  [RUNNING] "run ",
+  [ZOMBIE] "zombie"
   };
   int i;
   struct proc *p;
@@ -532,13 +797,122 @@ procdump(void)
     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
+    state = "???";
+  cprintf("%d %s %s", p->pid, state, p->name);
     if(p->state == SLEEPING){
       getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+    for(i=0; i<10 && pc[i] != 0; i++)
+      cprintf(" %p", pc[i]);
+    }
+  cprintf("\n");
+  }
+}
+
+int
+detach(int pid)
+{
+  struct proc *p;
+  struct proc *curproc = myproc();
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid==pid && p->parent == curproc ){
+      p->parent=initproc;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//Set the priority of a process to the varible that we get
+void 
+priority(int prio){
+  acquire(&ptable.lock);
+  switch(current){
+    case RRQ:
+    case PQ:
+    if(prio>0&& prio<11){
+      myproc()->priority=prio;     
+    }
+    else{
+      myproc()->priority=5;
+    }
+    break;
+    case EPQ:
+      if(prio>-1 && prio <11){
+        myproc()->priority=prio;
+      }
+      else{
+      myproc()->priority=5;
     }
-    cprintf("\n");
+    break;
   }
+ 
+ release(&ptable.lock);
 }
+
+void
+update_fields(void)
+{
+  struct proc *p;
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED || p==initproc)
+    continue;
+    if(p->state == RUNNING)
+    {
+        p->rutime++;
+    }
+    if(p->state == RUNNABLE)
+    {
+          p->retime++;
+    }
+        if(p->state == SLEEPING)
+    {
+        p->stime++;
+    }
+  }
+}
+
+//when we are moving to policy RRQ
+void change_accumulator_to_zero(){
+   struct proc *p;
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      p->accumulator=0;
+    }
+}
+
+//when we are moving to policy PQ 
+void change_priority_from_zero_to_one()
+{  
+   struct proc *p;
+   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->priority==0){
+        p->priority=1;
+      }
+    }
+}
+
+
+void policy(int pol)
+{
+  acquire(&ptable.lock);
+  if(pol==RRQ){
+        change_accumulator_to_zero();
+        pq.switchToRoundRobinPolicy();
+        current=pol;
+  }
+   else if(pol==PQ || pol==EPQ){
+          if(pol==PQ){
+            change_priority_from_zero_to_one();
+          }
+          //this will happend anyway. 
+          rrq.switchToPriorityQueuePolicy();
+          current=pol;
+      }
+   else{
+        current=RRQ;
+        pq.switchToRoundRobinPolicy();
+    }
+  release(&ptable.lock);
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 6ad690e..c2fb9b4 100644
--- a/proc.h
+++ b/proc.h
@@ -11,7 +11,7 @@ struct cpu {
   int intena;                  // Were interrupts enabled before pushcli?
   struct proc *proc;           // The process running on this cpu or null
 };
-
+void update_fields(void);
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
@@ -34,6 +34,14 @@ struct context {
   uint eip;
 };
 
+struct perf {
+int ctime;
+int ttime;
+int stime;
+int retime;
+int rutime;
+};
+
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
 // Per-process state
@@ -51,6 +59,16 @@ struct proc {
   struct file *ofile[NOFILE];    // Open files
   struct inode *cwd;             // Current directory  
   char name[16];                 // Process name (debugging)
+  int status;                    // Process status
+  int priority;                  // Process priority
+  long long accumulator;         // Process accumulator that adds the priorities
+  long long last_running_time;   // save the last runnig time of the procces
+  int ctime;                     // process creation time
+  int ttime;                     // process termination time
+  int stime;                     // the total time the process spent in the SLEEPING state
+  int retime;                    // the total time the process spent in the READY state
+  int rutime;                    // the total time the process spent in the RUNNING state
+
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/rm.c b/rm.c
index 4fd33c8..83c5f36 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..98f0a78
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,164 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+
+void fib(int n) 
+{
+	if (n <= 1)
+		return;
+	fib(n-1);
+	fib(n-2);
+}
+
+int fact(int n)
+{
+	if(n==1|| n==0)
+		return 1;
+	return n*fact(n-1);
+}
+
+int ack(int a, int b) 
+{
+if (a == 0) { return b + 1; }
+else if (b == 0) { return ack(a - 1, 1); }
+else { return ack(a - 1, ack(a, b - 1)); }
+}
+
+int gcd(int a, int b) 
+{ 
+    if (a == 0) 
+       return b; 
+    if (b == 0) 
+       return a; 
+    if (a == b) 
+        return a;  
+    if (a > b) 
+        return gcd(a-b, b); 
+    return gcd(a, b-a); 
+} 
+
+void workIo(){
+	int i;
+	for (i=0; i<1750 ;i++)
+	 	sleep(1);
+}
+
+void workFib(){
+	fib(5);
+}
+
+void workAck(){
+	ack(3,2);
+}
+
+void workGcd(){
+	gcd(4,2);
+}
+
+void workFact(){
+	fact(5);
+}
+
+struct perf {
+  int ctime;
+  int ttime;
+  int stime;
+  int retime;
+  int rutime;
+};
+
+void printStat(struct perf * myPerf, int status){
+	printf(1, "%d process creation time: %d\n",status, myPerf->ctime);
+	printf(1, "%d process termination time: %d\n",status, myPerf->ttime);
+	printf(1, "%d process SLEEPING time: %d\n",status, myPerf->stime);
+    printf(1, "%d process READY time: %d\n",status, myPerf->retime);
+    printf(1, "%d process RUNNING time: %d\n",status, myPerf->rutime);
+
+	if(myPerf->ttime-myPerf->ctime!=0){
+		// (the time it was ready (runnable) / the time he was active (end-create) )* 100
+		printf(1, "%d Spent %d\% as runnable\n",status, (myPerf->retime*100/(myPerf->ttime-myPerf->ctime)));
+		// (the rim it was sleeping / the time he was active (end-create)) * 100 
+		printf(1, "%d Spent %d\% in sleep\n",status, (myPerf->stime*100/(myPerf->ttime-myPerf->ctime)));
+	}
+    printf(1, "\n");
+}
+
+
+int main( int argc, char **argv) {
+	int pid ;
+	int pid1;
+	int pid2;
+	int first_status=0;
+	int second_status=0;
+	int third_status=0;
+	int case_to_check=atoi(argv[1]);
+	int status;
+    struct perf myPerf;
+    int i; 			
+
+	switch(case_to_check){
+	case 1:
+	    for (i=0; i < 30; i++){
+		    if (fork()==0){
+		    	if (i%2 == 0){
+		    		workIo();
+		    	}
+				else if(i%2==1){
+					 workAck();
+					//workFib();
+					//workGcd();
+					//workFact();
+				}
+				//we want to give each process diffrent status so we can print it
+		    	exit(i);
+		    }
+		}
+		for (i=0; i<30; i++){
+			wait_stat(&status, &myPerf);
+			printStat(&myPerf, status);
+		}
+		exit(0);
+		break;
+	case 2:
+		pid = fork();
+		if (pid == 0) {
+			sleep(300);
+			// we put 5 in the status and then we will print the status 
+			exit(5);
+		}
+		else {
+			int* status = malloc(1);
+			wait(status);
+			printf(1, "exit status after is %d\n",*status);
+		}
+		exit(0);
+		break;
+	case 3:
+		pid1 = fork();
+		if(pid1 > 0) {
+		first_status=detach(pid1); // status = 0
+		second_status = detach(pid1); // status = -1, because this process has already
+			// // detached this child, and it doesn’t have
+			// // this child anymore.
+		third_status = detach(pid1-1); // status = -1, because this process doesn’t
+			// have a child with this pid.
+		printf(1,"Father process- should be 0 and the actual status is: %d \n Father process (second time) - should be -1 and the actual status is: %d \n undefined process- should be -1 and the actual status is : %d \n",first_status, second_status, third_status);
+		}
+		if(pid1==0){
+			pid2=fork();
+			if(pid2 > 0) {
+				first_status=detach(pid2); 
+				second_status = detach(pid1); 
+				third_status = detach(pid2); 
+				printf(1,"child process- should be 0 and the actual status is: %d \n father process (second time) - should be -1 and the actual status is: %d \n child process (second time)- should be -1 and the actual status is : %d \n",first_status, second_status, third_status);
+			}
+		}
+		exit(0);
+		break;
+		default:
+		 exit(0);
+	}
+	printf(1, "\n");
+}
\ No newline at end of file
diff --git a/sh.c b/sh.c
index 054bab9..8038092 100644
--- a/sh.c
+++ b/sh.c
@@ -57,15 +57,20 @@ struct cmd *parsecmd(char*);
 void
 runcmd(struct cmd *cmd)
 {
+  int status;
   int p[2];
   struct backcmd *bcmd;
   struct execcmd *ecmd;
   struct listcmd *lcmd;
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
-
+  char data[1];
+  char strPath[512];
+  int indexargv = 0;
+  char* myCmd;
+  int fd;
   if(cmd == 0)
-    exit();
+    exit(0);
 
   switch(cmd->type){
   default:
@@ -73,10 +78,29 @@ runcmd(struct cmd *cmd)
 
   case EXEC:
     ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
-      exit();
+    myCmd=ecmd->argv[0];
+    if(ecmd->argv[0] == 0){
+      exit(0);
+      }
     exec(ecmd->argv[0], ecmd->argv);
+    fd = open("/path", O_RDONLY);
+    while(read(fd, data, 1) > 0){
+      if(data[0]!=':'){
+          strPath[indexargv]=data[0];
+          indexargv++;   
+        }
+      else{
+   
+        strcpy(strPath+indexargv,myCmd);
+        indexargv = 0;
+       // printf(2,"%s\n",strPath);
+        exec(strPath, ecmd->argv);
+         strcpy(strPath,"");
+
+        }
+    }
     printf(2, "exec %s failed\n", ecmd->argv[0]);
+    close(fd);   
     break;
 
   case REDIR:
@@ -84,7 +108,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit();
+      exit(0);
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +117,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait();
+    wait(&status);
     runcmd(lcmd->right);
     break;
 
@@ -117,8 +141,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait();
-    wait();
+    wait(&status);
+    wait(&status);
     break;
 
   case BACK:
@@ -127,7 +151,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit();
+  exit(0);
 }
 
 int
@@ -146,7 +170,13 @@ main(void)
 {
   static char buf[100];
   int fd;
-
+  int status; 
+  int fdPath;
+  fdPath=open("/path", O_CREATE | O_RDWR);
+  mkdir("mor");
+  write(fdPath, "/:/mor/:/bin/:",14);
+  
+ // write(Openpath ,"/");
   // Ensure that three file descriptors are open.
   while((fd = open("console", O_RDWR)) >= 0){
     if(fd >= 3){
@@ -166,16 +196,16 @@ main(void)
     }
     if(fork1() == 0)
       runcmd(parsecmd(buf));
-    wait();
+    wait(&status);
   }
-  exit();
+  exit(0);
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit();
+  exit(0);
 }
 
 int
@@ -456,6 +486,7 @@ nulterminate(struct cmd *cmd)
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
 
+  
   if(cmd == 0)
     return 0;
 
diff --git a/stressfs.c b/stressfs.c
index c0a4743..06a07ca 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait();
+  wait(0);
 
-  exit();
+  exit(0);
 }
diff --git a/syscall.c b/syscall.c
index ee85261..289085d 100644
--- a/syscall.c
+++ b/syscall.c
@@ -18,7 +18,6 @@ int
 fetchint(uint addr, int *ip)
 {
   struct proc *curproc = myproc();
-
   if(addr >= curproc->sz || addr+4 > curproc->sz)
     return -1;
   *ip = *(int*)(addr);
@@ -103,6 +102,13 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_detach(void);
+extern int sys_priority(void);
+extern int sys_policy(void);
+extern int sys_wait_stat(void);
+
+
+
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +132,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_detach]  sys_detach,
+[SYS_priority]  sys_priority,
+[SYS_policy]  sys_policy,
+[SYS_wait_stat]  sys_wait_stat,
+
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..99e05c5 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_detach 22
+#define SYS_priority 23
+#define SYS_policy 24
+#define SYS_wait_stat 25
+
diff --git a/sysproc.c b/sysproc.c
index 0686d29..5bf9be8 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -16,14 +16,30 @@ sys_fork(void)
 int
 sys_exit(void)
 {
-  exit();
-  return 0;  // not reached
+int status;
+
+  if(argint(0, &status) < 0)
+    return -1;
+   exit(status);
+   return 0;
 }
 
+int
+sys_detach(void)
+{
+int status;
+  if(argint(0, &status) < 0)
+    return -1;
+  return detach(status);
+  }
+
 int
 sys_wait(void)
 {
-  return wait();
+  int* status;
+  if(argptr(0, (char**)&status,4) < 0)
+    return -1;
+  return wait(status);
 }
 
 int
@@ -77,15 +93,51 @@ sys_sleep(void)
   return 0;
 }
 
+
+int 
+sys_priority(void)
+{
+  int acc;
+   if(argint(0, &acc) < 0)
+    return -1;
+   priority(acc);
+   return 0;
+}
+
+int
+sys_policy(void){
+  int pol;
+  if(argint(0, &pol) < 0)
+    return -1;
+  policy(pol);
+  return 0;
+}
+
+
+int
+ sys_wait_stat(void) {
+  int pid;
+  int status;
+  int performance;
+  
+  if (argint(1, &performance) < 0)
+    {return -1;}
+    if (argint(0, &status) < 0)
+    {return -1;}
+  pid = wait_stat((int*)status, (struct perf*) performance); 
+  return pid;
+}
+
 // return how many clock tick interrupts have occurred
 // since start.
 int
 sys_uptime(void)
 {
   uint xticks;
-
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
   return xticks;
 }
+
+
diff --git a/trap.c b/trap.c
index 41c66eb..2bbfeda 100644
--- a/trap.c
+++ b/trap.c
@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
-      exit();
+      exit(0);
     myproc()->tf = tf;
     syscall();
     if(myproc()->killed)
-      exit();
+      exit(0);
     return;
   }
 
@@ -51,6 +51,7 @@ trap(struct trapframe *tf)
     if(cpuid() == 0){
       acquire(&tickslock);
       ticks++;
+      update_fields();
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -98,7 +99,7 @@ trap(struct trapframe *tf)
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
@@ -108,5 +109,5 @@ trap(struct trapframe *tf)
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 }
diff --git a/user.h b/user.h
index 4f99c52..bc50b16 100644
--- a/user.h
+++ b/user.h
@@ -1,10 +1,11 @@
 struct stat;
 struct rtcdate;
+struct perf;
 
 // system calls
 int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
+void exit(int status) __attribute__((noreturn));
+int wait(int *status);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
@@ -23,6 +24,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int detach(int);
+void priority(int);
+void policy(int);
+int wait_stat(int* status, struct perf * performance);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..d5421dd 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,10 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(detach) 
+SYSCALL(priority)
+SYSCALL(policy)
+SYSCALL(wait_stat)
+
+
+
diff --git a/wc.c b/wc.c
index d6a54df..1d4f708 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit();
+    exit(0);
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/zombie.c b/zombie.c
index ee817da..c96b92d 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit();
+  exit(0);
 }
